//  Copyright 2024 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Based on the Hindley-Milner algorithm, see
// https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
// for an introduction.
//
// To see how it works, consider the following expression:
//
//   1 + (2 * 3)
//
// with (a simplified representation of the AST for this comment):
//   root: BinaryOp(PLUS,
//     n0:   Uint64(1),
//     n1:   BinaryOp(TIMES,
//    n10:    Uint64(2),
//    n11:    Uint64(3)
//           )
//         )
//
// The algorithm is 'syntax-directed': it builds a type for a node
// directly from the types of its children. The algorithm starts
// at the root:
//
//     1. It is the binary operator PLUS, look up its type:
//           BPOLY(1, [STR, NUM], FN(TUPLE([v, v]), v))
//             (in symbols: forall v1:string|num. (v1, v1) -> v1))
//
//           (this is a "bounded polymorphic function" that takes one
//            type variable 'v1'. The type variable is 'bound' in that
//            it is limited to be either a string (STR) or a numeric (NUM)
//            type. (NUM here means Int | Uint | f32 | f64.))
//
//     2. Recursively typecheck the children:
//           n0 has type Uint64
//           n1 has type Uint64
//
//     3. Apply the type in (2) to the children. This involves
//
//          (a) "opening" the bounded polymorphic type. That is,
//              i. generate a new type variable, 'x', where x is a
//                 hitherto unused type variable number. Note that in our
//                 algorithm, variables generated by opening polymorphic
//                 types have negative numbers, while those inferred for
//                 functions are positive.
//             ii. attach the type constraint [STR, NUM] to the new variable
//            iii. instantiate the body to become:
//                   (vx:str|num, vx:str|num) -> vx:str|num
//
//          (b) "apply" this new function type to the types in (3):
//              i. unify argument type (vx:str|num, vx:str|num)
//                 to (typeof(n0), typeof(n1))
//
//                 unification of tuple types is just sequential unification
//                 of child types. So
//
//             ii. unify the left side of the fn param tuple, vx:str|num
//                 against the left size of the arg tuple, typeof(n0)=Uint64
//                 vx is not instantiated, but it does have the constraint
//                 str|num.  Uint64 belongs to 'num' so the constraint succeeds,
//                 which means vx is now bound to concrete type Uint64.
//
//            iii. unify the right side of the fn param tuple, vx:str|num=Uint64
//                 against the right side of the arg tuple, typeof(n1)=Uint64.
//                 Since vx is already bound, this becomes
//                 unify Uint64 with Uint64, which succeeds because they are
//                 identical types.
//
//             iv. Finally, we return the 'result type' of the function, which
//                 is just vx:str|num=Uint64.
//
// This simple example shows what happens with an ill-formed expression.
// Consider
//
//    1 + "Hello, world!"
//
// or
//    root: BinaryOp(PLUS,
//      n0:   Uint64(1),
//      n1:   String("Hello, world!")
//          )
//
// Following the above typechecking process, we fail at step 3(b).iii above:
//
//   The type variable vx:str|num will have been bound to type Uint64 in
//   step 3(b).ii. When we come to apply the right hand side of the fn param
//   tuple, vx:str|num=Uint64 against the right hand side of the arg tuple,
//   typeof(n1)=string, we end up trying to unify type Uint64 against type
//   string, which fails because they are not equal.
//
// Inferring polymorphic types for definitions.
//
// The above algorithm instantiates existing types. However, we also need to
// infer new polymorphic types for user-defined functions. Consider the function
//
//     func id (x) {
//         return x
//     }
//
// We intuitively know that it is polymorphic in the argument x.  It should have
// type POLY(1, FN(v, v))  -- in symbols:  forall v1.(v1 -> v1).
//
// Type generalization occurs at definitions. We start by generating type variables
// for the parameters, here, x has type v1.  Then, using the above algorithm we
// typecheck the body of the function -- it returns a value of type v1.
//
// Since this is a func, we can infer its type to be
//
//    <typeof parameters> -> <typeof result>
//
// In this example, this boils down to  v1 -> v1.  Since we know that the variable
// v1 was introduced in this function definition (we generated it for parameter x),
// we know that we can bind it to become forall v1.(v1 -> v1).


import database as db
use sym
use builtins
use typeclasses
use typeunifier
use typebuilder
use typeerror

TypeErrorPrefix = ": "

STR = STRING()
BOOL = BOOLEAN()
INT = INTEGER()
UINT = UINTEGER()
ANYINT = ANYINTEGER()
NUM = NUMBER()

class SymbolMapping(self, key: Sym, ty: Type?) {
  self.key = key
  self.value = ty

  func hash(self) -> u64 {
    return hashValue(self.key.name)
  }

  func equals(self, other: SymbolMapping) -> bool {
    return self.key == other.key
  }
}

relation DoublyLinked BindingScope SymbolMapping cascade

class BindingScope(self) {
  func add(self, sm: SymbolMapping) {
    self.appendSymbolMapping(sm)
  }
}

relation HashedClass TypeChecker SymbolMapping cascade
relation DoublyLinked TypeChecker BindingScope cascade
relation DoublyLinked TypeChecker TypeError cascade

class TypeChecker(self) {
  self.unifier = TypeUnifier()
  self.nextTyvarId = 1i32
  self.numTypeErrorsReported = 0
  self.openScope()

  func typeError(self, msg: string, location: db.Location?) {
    self.appendTypeError(TypeError(msg, location))
  }

  func popTypeError(self) {
    if !isnull(self.lastTypeError) {
      self.removeTypeError(self.lastTypeError!)
    }
  }

  func dumpTypeErrors(self, dumpText: bool = true, prefix: string = "") {
    count = self.countTypeErrors()
    pos = self.numTypeErrorsReported

    while pos < count {
      te = self.indexTypeError(pos)
      if !isnull(te.location) {
        te.location.error(te.msg, dumpText, prefix)
      } else {
        println prefix + "Type error: %s" % te.msg
      }
      self.numTypeErrorsReported += 1
      pos += 1
    }
  }

  func openScope(self) {
    self.appendBindingScope(BindingScope())
  }

  func closeScope(self) -> BindingScope {
    scope = self.lastBindingScope!
    self.removeBindingScope(scope)
    return scope
  }

  func newSymbol(self, symbol: Sym, ty: Type?) -> Type? {
    // TODO: there may already exist a symbol mapping, if we are creating
    // a symbol with the same name as another in an outer scope.
    if isnull(ty) {
      type = Type(self.newTyvar())
    } else {
      type = ty
    }
    sm = SymbolMapping(symbol, type)
    self.insertSymbolMapping(sm)
    self.lastBindingScope.add(sm)
    symbol.typedValue = type
    return type
  }

  func newTyvar(self) -> TypeVar {
    tyvar = TypeVar(self.nextTyvarId, null(Type))
    self.nextTyvarId += 1
    return tyvar
  }

  func unify(self, a: Type, b: Type) -> TypeError? {
    return self.unifier.unify(a, b)
  }

  func dumpTypeBindings(self) {
    self.unifier.dump()
  }

  func instantiate(self, poly: PolymorphicType, inst: TyvarInstantiation) {
    // for a limited time, pretend that the bound variables in poly are bound
    // to the bindings in the instantiation.
    assert poly.boundVars.length() == inst.varBindings.length()
    for index in range(poly.boundVars.length()) {
       assert poly.boundVars[index].type == Type.TypeClass.Var
       btv = poly.boundVars[index].tyvar!
       val = self.unifier.lookupVar(btv.id)
       if !isnull(val) {
         println "Error: bound variable ", btv.toString(), " is already bound to ", val.toString()
         assert(false)
       }
       binding = inst.varBindings[index]
       self.unifier.bindVar(btv, binding)
    }
  }

  func deInstantiate(self, poly: PolymorphicType) {
    // for a limited time, pretend that the bound variables in poly are bound
    // to the bindings in the instantiation.
    for ty in poly.boundVars {
      assert ty.type == Type.TypeClass.Var
      self.unifier.unbindVar(ty.tyvar!)
      assert isnull(self.unifier.lookupVar(ty.tyvar.id))
    }
  }


  // ---------------------------------- Type checking functions ----------------------

  func resolve(self, t: Type) -> Type {
    switch t.type {
      Type.TypeClass.Var => {
        t2 = self.unifier.resolveVar(t.tyvar!.id)
        if !isnull(t2) {
          return t2!
        }
        return t
      }
      Type.TypeClass.Int => return t
      Type.TypeClass.AnyInt => return t
      Type.TypeClass.Float => return t
      Type.TypeClass.Typename => return t
      Type.TypeClass.Choice => {
        choices = arrayof(Type)
        for choice in t.choice!.choices {
          choices.append(self.resolve(choice))
        }
        return Type(ChoiceType(choices))
      }
      Type.TypeClass.Tuple => {
        elements = arrayof(Type)
        for child in t.tuple!.elements {
          elements.append(self.resolve(child))
        }
        return Type(TupleType(elements))
      }
      Type.TypeClass.Function => {
        return Type(FunctionType(self.resolve(t.function!.params),
                                 self.resolve(t.function!.result)))
      }
      Type.TypeClass.Polymorphic => {
        // We want to resolve any free variables in the scope of the
        // polymorphic type. However, first make sure that no bound variable
        // exists in the unifier.
        //
        // It's unclear why we need to generate a new array of bound variables,
        // if we try to share the existing one, we (sometimes) end up generating
        // a new PolymorphicType with empty variables.
        newvars = arrayof(Type)
        for boundVar in t.poly!.boundVars {
          assert isnull(self.unifier.lookupVar(boundVar.tyvar.id))
          newvars.append(boundVar)
        }
        pt = PolymorphicType(newvars, self.resolve(t.poly!.scope),
                             t.poly.instantiations)
        return Type(pt)
      }
    }
  }

  func apply(self, function: Type, args: Type,
             location: db.Location? = null(db.Location)) -> Type? {
    ty = function
    if ty.type == Type.TypeClass.Var {
      ty = self.resolve(ty)
      if ty.type == Type.TypeClass.Var {
        // This will happen in the body of a recursive function, when it attempts
        // to apply itself for the first time.  Initially, the function identifier
        // is set to a type variable.
        newty = FN(Type(self.newTyvar()), Type(self.newTyvar()))
        te = self.unifier.unify(ty, newty, location)
        assert(isnull(te))
        ty = newty
      }
    }
    switch ty.type {
      Type.TypeClass.Function => {
        te = self.unifier.unify(ty.function!.params, args, location)
        if !isnull(te) {
          self.typeError("could not unify\n%s    parameters of function %s\n%s    with args %s:\n%s%s"
                          % (TypeErrorPrefix, ty.toString(),
                             TypeErrorPrefix, args.toString(), TypeErrorPrefix, te.msg),
                         location)
          return null(Type)
        }
        return self.resolve(ty.function!.result)
      }

      Type.TypeClass.Polymorphic => {
        f2 = ty.poly!.open(self.unifier, &self.unifier.newVar())
        return self.apply(f2, args, location)
      }

      Type.TypeClass.Choice => {
        countErrors = 0
        for choice in ty.choice!.choices {
           ty2 = self.apply(choice, args, location)
           if !isnull(ty2) {
             // make sure that there are no type errors -- we can ignore
             // any errors from previous branch attempts.
             while countErrors > 0 {
               self.popTypeError()
               countErrors -= 1
             }
             return ty2
           }
           countErrors += 1
        }
        self.typeError("Failed to apply any choice of function type %s to %s."
                       % (ty.toString(), args.toString()),
                       location)
        return null(Type)
      }
      default => {
        self.typeError("attempting to apply a non-function %s to %s."
                         % (ty.toString(), args.toString()), location)
        return null(Type)
      }
    }
  }

  // ------------------------- Typecheck explicit type expressions ---------------------

  func explicitType(self, typeExpr: db.Expr) -> Type {
    switch typeExpr.type {
      db.ExprType.UintType => return U(<u64>typeExpr.width)
      db.ExprType.IntType =>  return I(<u64>typeExpr.width)
      db.ExprType.FloatType => return F(<u64>typeExpr.width)
      db.ExprType.StringType => return STR
      db.ExprType.BoolType => return BOOL
      db.ExprType.NoneType => return NONETY()
      default => raise Status.Unimplemented, "TypeExpression type not yet supported by C backend", typeExpr.type
    }
  }


  // ------------------------- Typechecking database structures ------------------------

  func symbol(self, symbol: Sym) -> Type? {
    sm = SymbolMapping(symbol, symbol.typedValue)
    found = self.findSymbolMapping(sm)
    if !isnull(found) {
      return found.value
    }
    return self.newSymbol(symbol, symbol.typedValue)
  }

  func getSymbolType(self, symbol: Sym) -> Type? {
    sm = SymbolMapping(symbol, null(Type))
    found = self.findSymbolMapping(sm)
    if !isnull(found) {
      return found.value
    }
    return null(Type)
  }

  func variable(self, v: db.Variable) -> Type? {
    // TODO: handle v.isConst
    if isnull(v.typeExpr) {
      ty = Type(self.newTyvar())
    } else {
      ty = self.explicitType(v.typeExpr!)
    }
    if v.isParam {
      self.newSymbol(v.sym, ty)
    } else {
      ty = self.symbol(v.sym)
    }

    if db.getRoot().traceTypes {
       v.location.annotation("\n[Typecheck] ", TypeErrorPrefix)
       println "%s%s" % (TypeErrorPrefix, ty.toString())
    }
    return ty
  }

  func value(self, val: db.Value) -> Type? {
    switch val.type {
      db.DatatypeType.Bool => return BOOL
      db.DatatypeType.String => return STR
      db.DatatypeType.Int => return I(<u64>val.width)
      db.DatatypeType.Uint => return U(<u64>val.width)
      db.DatatypeType.Float => return F(<u64>val.width)
      db.DatatypeType.Sym => return self.symbol(val.symVal!)
      default => raise Status.Unimplemented, "Value type not yet supported by typechecker: ", val.type
    }
  }

  // ---- typecheck expressions
  func expr(self, expr: db.Expr) -> Type? {
    result = null(Type)
    switch expr.type {
      db.ExprType.Constant => result = self.value(expr.val)
      db.ExprType.Ident => result = self.value(expr.val)

      db.ExprType.List, db.ExprType.Tuple => {
        elements = arrayof(Type)
        for child in expr.childExprs() {
          ty = self.expr(child)
          if isnull(ty) {
            return ty
          }
          elements.append(ty!)
        }
        result = Type(TupleType(elements))
      }

      // Binary expressions --------------------------------------------------
      db.ExprType.Add, db.ExprType.Div, db.ExprType.Mul, db.ExprType.Sub, db.ExprType.Bitxor, db.ExprType.AddTrunc, db.ExprType.MulTrunc, db.ExprType.SubTrunc, db.ExprType.Bitand, db.ExprType.Bitor, db.ExprType.Or, db.ExprType.Exp, db.ExprType.Mod, db.ExprType.And, db.ExprType.Or, db.ExprType.Xor, db.ExprType.Shl, db.ExprType.Shr, db.ExprType.Rotl, db.ExprType.Rotr, db.ExprType.Lt, db.ExprType.Le, db.ExprType.Gt, db.ExprType.Ge, db.ExprType.Equal, db.ExprType.Notequal, db.ExprType.Equals, db.ExprType.Equals, db.ExprType.AddEquals, db.ExprType.SubEquals, db.ExprType.MulEquals, db.ExprType.DivEquals, db.ExprType.ModEquals, db.ExprType.AndEquals, db.ExprType.OrEquals, db.ExprType.XorEquals, db.ExprType.BitandEquals, db.ExprType.BitorEquals, db.ExprType.BitxorEquals, db.ExprType.ExpEquals, db.ExprType.ShlEquals, db.ExprType.ShrEquals, db.ExprType.RotlEquals, db.ExprType.RotrEquals, db.ExprType.AddTruncEquals, db.ExprType.SubTruncEquals, db.ExprType.MulTruncEquals => {
        left = self.expr(expr.firstChildExpr!)
        right = self.expr(expr.firstChildExpr!.nextExprChildExpr!)
        if isnull(left) || isnull(right) {
          return left
        }
        opty = builtinType(expr.type)
        argty = Type(TupleType([left!, right!]))
        result = self.apply(opty, argty, expr.location)
     }

      db.ExprType.Index => {
        left = self.expr(expr.firstChildExpr!)
        rightChild = expr.firstChildExpr!.nextExprChildExpr!
        right = self.expr(rightChild)
        if isnull(left) || isnull(right) {
          return left
        }
        if left.type == Type.TypeClass.Tuple {
          // Index must be an unsigned integer.
          te = self.unify(right!, UINTEGER())
          if isnull(te) {
            self.typeError(
             "Tuple index must be an unsigned integer, not %s." % right.toString(),
              expr.location)
          } else if rightChild.type != db.ExprType.Constant {
            self.typeError(
             "Tuples may only be indexed by unsigned integer literal, not %s." % rightChild.toString(),
             expr.location)
          } else {
            index = rightChild.val.intVal
            if index.width <= 64u32 {
              i = index.uint64()
              if i < left.tuple.numElements() {
                result = left.tuple.index(i)
              }
            }
            if isnull(result) {
              self.typeError(
               "Tuple index %u is larger than size of tuple %s." % (index, left.toString()),
               expr.location)
            }
          }
        } else {
          self.typeError(
            "Cannot index into type %s." % left.toString(), expr.location)
        }
      }

      // Unary expressions ----------------------------------------------------------
      db.ExprType.Negate, db.ExprType.Bitnot, db.ExprType.Not => {
        childType = self.expr(expr.firstChildExpr!)
        if isnull(childType) {
          return childType
        }
        opty = builtinType(expr.type)
        result = self.apply(opty, childType!, expr.location)
      }

      db.ExprType.Call => {
        fn = self.expr(expr.firstChildExpr!)
        child = expr.firstChildExpr!.nextExprChildExpr
        args = self.expr(child!)
        if isnull(fn) || isnull(args) {
          return fn
        }
        result = self.apply(fn!, args!, expr.location)
      }

      default => raise Status.Unimplemented, "Expression type not yet supported by typechecker: ", db.getExprTypeName(expr.type)
    }

    if db.getRoot().traceTypes {
       expr.location.annotation("\n[Typecheck] ", TypeErrorPrefix)
       if isnull(result) {
         println "%sType Error!" % TypeErrorPrefix
         // Dump latest type errors as we go. These won't repeat errors already
         // reported. We've already printed the line and caret marks, so don't print them again
         self.dumpTypeErrors(false, TypeErrorPrefix)
       } else {
         println "%s%s" % (TypeErrorPrefix, result.toString())
       }
    }
    if !isnull(result) {
      result = self.resolve(result!)
    }
    expr.typedValue = result
    return result
  }


  // Statements -------------------------------------------------------------
  func statement(self, statement: db.Statement, parent: db.Block) {
    switch statement.type {
      db.StateType.Assign => self.expr(statement.expr)
      db.StateType.Call => self.expr(statement.expr)
      db.StateType.Print => self.expr(statement.expr)
      db.StateType.Println => self.expr(statement.expr)
      db.StateType.If => {
        ty = self.expr(statement.expr)
        te = self.unify(ty!, BOOL)
        if !isnull(te) {
          self.typeError("Condition expression must be a boolean", statement.expr.location)
        }
        assert !isnull(statement.subBlock)
        for s in statement.subBlock.statements() {
          self.statement(s, statement.subBlock)
        }
        parent.returnType = statement.subBlock.returnType
      }
      db.StateType.Else => {
        assert !isnull(statement.subBlock)
        for s in statement.subBlock.statements() {
          self.statement(s, statement.subBlock)
        }
        parent.returnType = statement.subBlock.returnType
      }
      db.StateType.ElseIf => {
        assert !isnull(statement.expr)
        ty = self.expr(statement.expr)
        te = self.unify(ty!, BOOL)
        if !isnull(te) {
          self.typeError("Condition expression must be a boolean", statement.expr.location)
        }
        assert !isnull(statement.subBlock)
        for s in statement.subBlock.statements() {
          self.statement(s, statement.subBlock)
        }
        parent.returnType = statement.subBlock.returnType
      }
      db.StateType.Return => {
        ty = self.expr(statement.expr)
        parent.returnType = ty
      }
      db.StateType.Return => return self.expr(statement.expr)
      default => raise Status.Unimplemented, "Statement type not yet supported by typechecker: ", db.statementTypeGetKeyword(statement.type)
    }
    return NONETY()
  }

  // Typecheck Functions, including modules ---------------------------------
  func function(self, fn: db.Function) {
    switch fn.type {
      db.FuncType.Module => {
        for childfunc in fn.childFunctions() {
          self.function(childfunc)
        }
        for statement in fn.subBlock.statements() {
          self.statement(statement, fn.subBlock)
        }
      }

      db.FuncType.Plain => self.plainFunction(fn)
      default => {
        raise Status.Unimplemented, "Function type not yet supported by typechecker: ", fn.type
      }
    }
  }

  func plainFunction(self, fn: db.Function) {
    // Todo: consider storage types
    if isnull(fn.typeExpr) {
      returnType = Type(self.newTyvar())
    } else {
      returnType = self.explicitType(fn.typeExpr)
    }

    // open new scope - new parameter bindings are added to the scope
    // automatically
    self.openScope()
    params = arrayof(Type)
    for variable in fn.variables() {
      param = self.variable(variable)!
      params.append(param)
    }
    if params.length() == 1 {
      paramType = params[0]
    } else {
      paramType = Type(TupleType(params))
    }
    bindingScope = self.closeScope()

    // must walk through all return statements.
    returnType = null(Type)
    for statement in fn.subBlock.statements() {
      self.statement(statement, fn.subBlock)
      if !isnull(fn.subBlock.returnType) {
        if isnull(returnType) {
          returnType = fn.subBlock.returnType
        } else {
          te = self.unify(returnType!, fn.subBlock.returnType!)
          if !isnull(te) {
            self.typeError(
               ("Conflicting return types\n%s    %s\n%s    and %s\n%s%s"
                 % (TypeErrorPrefix, returnType.toString(),
                    TypeErrorPrefix, fn.subBlock.returnType.toString(),
                    TypeErrorPrefix, te.msg)),
               fn.location)
          }
        }
      }
    }

    // Make sure that the explicit return type, if it exists, agrees with
    // the type computed from the function body.
    if !isnull(fn.typeExpr) {
        explicitReturnType = self.explicitType(fn.typeExpr)
        if isnull(returnType) {
            returnType = explicitReturnType
        } else {
            te = self.unify(returnType!, explicitReturnType)
            if !isnull(te) {
                self.typeError(
                    ("Could not unify\n%s    explicit return type %s\n%s    with %s:\n%s%s"
                      % (TypeErrorPrefix, fn.typeExpr.toString(),
                         TypeErrorPrefix, ty.toString(), TypeErrorPrefix, te.msg)),
                    fn.location)
           }
        }
    }

    if isnull(returnType) {
      returnType = Type(TypeName("none"))
    }
    // Replace type variables in the parameters and return type with their
    // instantiations, if any.
    paramType = self.resolve(paramType)
    returnType = self.resolve(returnType!)

    fnType = Type(FunctionType(paramType, returnType!))
    boundVars = arrayof(Type)
    for sm in bindingScope.symbolMappings() {
      if !isnull(sm.value) && sm.value.type == Type.TypeClass.Var {
        // Has this type variable been instantiated?
        ty = self.resolve(sm.value!)
        if ty.type == Type.TypeClass.Var {
          boundVars.append(Type(ty.tyvar!))
        }
      }
    }
    if boundVars.length() > 0 {
      fnType = Type(PolymorphicType(boundVars, fnType))
    }

    // associate function name symbol to this type.
    self.newSymbol(fn.sym, fnType)

    if db.getRoot().traceTypes {
       fn.location.annotation("\n[Typecheck] ", TypeErrorPrefix)
       println "%s%s" % (TypeErrorPrefix, fnType.toString())
       println "%s%s: %s" % (TypeErrorPrefix, fn.sym.name, fnType.toString())
    }
  }
}


unittest TypeClasses {
  // Instantiate all the type classes so that they get compiled.
  v = TypeVar(0i32, null(Type))
  i = IntType(true, 3u32)
  f = FloatType(32u32)
  c = ChoiceType([Type(IntType(true, 32u32))])
  t = TupleType([Type(IntType(true, 32u32))])
  tn = TypeName("boo")
  fn = FunctionType(Type(tn), Type(tn))
  p = PolymorphicType(0u64, TypeVar(0i32, null(Type)), Type(IntType(true, 32u32)))
  p.toString()
}

unittest TypeApplyTest {
  tc = TypeChecker()
  assert tc.apply(FN(STR, INT), STR) == INT
  assert isnull(tc.apply(FN(STR, INT), INT))
  assert tc.apply(FN(INT, STR), I(64)) == STR
  assert tc.apply(POLY(1, FN(V(1), V(1))), BOOL) == BOOL
  assert isnull(tc.apply(BPOLY(1, [ANYINT], FN(V(1), V(1))), BOOL))
}

unittest SimpleTypeCheckTest {
  filepath = db.Filepath.new("test_filepath", null(db.Filepath), false)
  location = db.Location(filepath, 0u32, 0u32, 0u32)
  left = db.Expr.newConstant(db.Value("Hello"), location)
  right = db.Expr.newConstant(db.Value("World"), location)
  expr = db.Expr.newBinary(db.ExprType.Lt, left, right, location)

  tc = TypeChecker()
  assert tc.expr(expr) == BOOL
}
