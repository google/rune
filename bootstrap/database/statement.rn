//  Copyright 2021 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use root
use datatype
use filepath
use location
use block
use expr
use rel
use value

import cbackend as c
import types

enum StateType {
  Assert
  If
  ElseIf
  Else
  Switch
  Case
  Default
  Do
  While
  For
  Assign
  Call
  Panic
  Print  // print "Hello, World!\n"
  Println  // println "Hello, World!"
  Try
  Except
  Raise
  Return
  Transform
  Relation
  Appendcode
  Prependcode
  Use
  Import
  ImportLib
  ImportRpc
  Foreach
  Yield
  Ref  // These two are used by transformers to manage reference counts.
  Unref
}

// Get the statement type keyword.
export func statementTypeGetKeyword(type: StateType) {
  switch type {
    StateType.Assert => return "assert"
    StateType.If => return "if"
    StateType.ElseIf => return "else if"
    StateType.Else => return "else"
    StateType.Do => return "do"
    StateType.While => return "while"
    StateType.For => return "for"
    StateType.Foreach => return "foreach"
    StateType.Assign => return "assignment"
    StateType.Call => return "call"
    StateType.Panic => return "panic"
    StateType.Print => return "print"
    StateType.Println => return "println"
    StateType.Try => return "try"
    StateType.Except => return "except"
    StateType.Raise => return "raise"
    StateType.Return => return "return"
    StateType.Switch => return "switch"
    StateType.Case => return "case"
    StateType.Default => return "default"
    StateType.Relation => return "relation"
    StateType.Transform => return "transform"
    StateType.Appendcode => return "appendcode"
    StateType.Prependcode => return "prependcode"
    StateType.Use => return "use"
    StateType.Import => return "import"
    StateType.ImportLib => return "importlib"
    StateType.ImportRpc => return "importrpc"
    StateType.Yield => return "yield"
    StateType.Ref => return "ref"
    StateType.Unref => return "unref"
  }
}

// Represents all statements in Rune.
class Statement(self, block: Block, type: StateType, location: Location) {
  self.type = type
  self.location = location
  self.instantiated = false
  self.executed = false  // Only for relation statements, so we don't execute them twice.
  self.generated = false // This statement was generated by a transformer or iterator.
  self.isFirstAssignment = false  // True if this is the first assignment to a variable, at top level.
  block.appendStatement(self)

  // Dump a statement to |text| without its sub-block.
  func dumpNoSubBlock(self:Statement, var text: string) {
    getRoot().indent(text)
    needSpace = false
    if self.type != StateType.Assign && self.type != StateType.Call {
      text.concat(statementTypeGetKeyword(self.type))
      needSpace = true
    }
    expr = self.expr
    if !isnull(expr) {
      if needSpace {
        text.append(' ')
      }
      expr.dumpToString(text)
    }
  }

  // Dump the statement to the end of |text| for debugging purposes.
  func dumpToString(self, var text: string) {
    self.dumpNoSubBlock(text)
    block = self.subBlock
    if !isnull(block) {
      text += " {\n"
      getRoot().incrementIndent()
      block.dumpToString(text)
      getRoot().decrementIndent()
      getRoot().indent(text)
      text += "}\n"
    } else {
      text += "\n"
    }
  }

  // Dump the statement to stdout for debugging purposes.
  func dump(self) {
    text = ""
    self.dumpToString(text)
    println text
  }

  // Copy a statement's expression and sub-block to the new statement.
  func copyExprAndSubBlock(self, newStatement: Statement) {
    expr = self.expr
    if !isnull(expr) {
      newExpr = expr.copy()
      newStatement.insertExpr(newExpr)
    }
    subBlock = self.subBlock
    if !isnull(subBlock) {
      newSubBlock = subBlock.copy()
      newStatement.insertSubBlock(newSubBlock)
    }
  }

  // Append a deep copy of the statement to destBlock.
  func appendCopy(self, destBlock: Block) -> Statement {
    newStatement = Statement(destBlock, self.type, self.location)
    self.copyExprAndSubBlock(newStatement)
    newStatement.instantiated = self.instantiated
    newStatement.executed = self.executed
    newStatement.generated = self.generated
    return newStatement
  }

  // Prepend a deep copy of the statement to destBlock.
  func prependCopy(self, destBlock: Block) -> Statement {
    newStatement = self.appendCopy(destBlock)
    // Move the statement to the start of the block.
    destBlock.removeStatement(newStatement)
    destBlock.insertStatement(newStatement)
    return newStatement
  }

  // Append a deep copy of the statement to destStatement's block, right after
  // |destStatement|.
  func appendCopyAfterStatement(self, destStatement: Statement) -> Statement {
    destBlock = destStatement.block!
    newStatement = self.appendCopy(destBlock)
    destBlock.removeStatement(newStatement)
    destBlock.insertAfterStatement(destStatement, newStatement)
    return newStatement
  }

  // C Generator .................................................

  func genC(self, builder: c.CBuilder) {
    switch self.type {
      StateType.Assign => self.genCAssign(builder)
      StateType.Print => self.genCPrint(builder, newline=false)
      StateType.Println => self.genCPrint(builder, newline=true)
      StateType.If => self.genCIf(builder)
      StateType.Else => self.genElse(builder)
      StateType.ElseIf => self.genElseIf(builder)
      StateType.Return => self.genCReturn(builder)
      default => raise Status.Unimplemented, "Statement type not yet supported by C backend builder ", self.type
    }
  }

  func genCAssign(self, builder: c.CBuilder) {
    assert isnull(self.subBlock)
    assert !isnull(self.expr)
    cexpr = self.expr.genC(builder)
    builder.addStatement(self.location, c.CStatement(self.location, c.CStatementType.Assignment, cexpr))
  }

  func genCCall(self, builder: c.CBuilder, fn: c.CExpr | c.CRuntimeFunction, args: c.CExpr?) {
    builder.addStatement(self.location, builder.cCall(self.location, fn, args))
  }

  func genCPrint(self, builder: c.CBuilder, newline: bool) {
    assert isnull(self.subBlock)
    assert !isnull(self.expr)

    // Println can write a list of expressions to standard out. Each
    // expression is printed immediately after one another. It is able to
    // generate string representations of many expressions, in particular
    // the values of built-in types and tuples.
    //
    // A special case is where the expression is an instance of the modulus
    // operator where the first argument is a string: in this case, it is
    // a printf-like expression, and we should generate an individual
    // printf format string.

    assert self.expr.type == ExprType.List

    self.genCCall(builder, c.CRuntimeFunction.GlobalStringWriterReset, null(c.CExpr))

    // Special case -- when argument is a single string.
    if (self.expr.countChildExprs() == 1
        && self.expr.indexChildExpr(0).type == ExprType.Constant
        && self.expr.indexChildExpr(0).val.type == DatatypeType.String) {
      // println/print with a single string should just printf that string.
      args = c.CExprList()
      args.appendCExpr(self.expr.indexChildExpr(0).genC(builder))
      cexpr = c.CExpr(args)
      call = builder.cCall(self.location, "tostring_string", cexpr)
      builder.addStatement(self.location, call)
    } else {
      for expr in self.expr.childExprs() {
        cexpr = null(c.CExpr)
        if expr.type == ExprType.Mod {
          left = expr.firstChildExpr!
          right = left.nextExprChildExpr!
          if left.type == ExprType.Constant && left.val.type == DatatypeType.String {
            args = c.CExprList()
            args.appendCExpr(builder.cStringLiteral(left.val.stringVal, printf=true))
            rgen = right.genC(builder)
            args.appendCExpr(rgen)
            cexpr = c.CExpr(args)
            self.genCCall(builder, c.CRuntimeFunction.GlobalStringWriterWrite, cexpr)
          }
        }
        if isnull(cexpr) {
          cexpr = expr.genC(builder)
          ctype = builder.genCType(expr.typedValue)
          assert !isnull(ctype)
          ctypename = ctype.toString()

          if ctypename == "string" {
            // String values need to be emitted with quotes.
            printfArgs = c.CExprList()
            printfArgs.append(builder.cStringLiteral("%s"))
            printfArgs.append(cexpr!)
            call = builder.cCall(self.location, "tostring_string", c.CExpr(printfArgs))
          } else {
            call = builder.cCall(self.location, "tostring_%s" % ctypename, cexpr)
          }
          builder.addStatement(self.location, call)
        }
      }
    }
    if newline {
      self.genCCall(builder, c.CRuntimeFunction.GlobalStringWriterWrite,
                    builder.cStringLiteral("\\n"))
    }
    // Finally generate the call to printf: printf("%s", GlobalStringWriterString())
    printfArgs = c.CExprList()
    printfArgs.append(builder.cStringLiteral("%s"))
    printfArgs.append(
        builder.cCall(self.location, c.CRuntimeFunction.GlobalStringWriterString,
                      null(c.CExpr)))
    self.genCCall(builder, c.CRuntimeFunction.Printf, c.CExpr(printfArgs))
  }

  func genCIf(self, builder: c.CBuilder) {
    assert !isnull(self.expr)
    assert !isnull(self.subBlock)
    ifStmt = builder.cIfStatement(
       self.location, self.expr.genC(builder), self.subBlock.genC(builder))
    builder.addStatement(self.location, ifStmt)
  }

  func genElse(self, builder: c.CBuilder) {
    assert isnull(self.expr)
    assert !isnull(self.subBlock)
    elseStmt = builder.cElseStatement(self.location, self.subBlock.genC(builder))
    builder.addStatement(self.location, elseStmt)
  }

  func genElseIf(self, builder: c.CBuilder) {
    assert !isnull(self.expr)
    assert !isnull(self.subBlock)
    elseIfStmt = builder.cElseIfStatement(
       self.location, self.expr.genC(builder), self.subBlock.genC(builder))
    builder.addStatement(self.location, elseIfStmt)
  }

  func genCReturn(self, builder: c.CBuilder) {
    assert isnull(self.subBlock)
    assert !isnull(self.expr)
    returnStmt = builder.cReturnStatement(self.location, self.expr.genC(builder))
    builder.addStatement(self.location, returnStmt)
  }
}

relation DoublyLinked Block Statement cascade
relation DoublyLinked Relation:"Generated" Statement:"Generated" cascade
relation OneToOne Root:"LastInitializer" Statement:"LastInitializer"

unittest basicStatementTest {
  filepath = Filepath.new("test_filepath", null(Filepath), false)
  location = Location(filepath, 0u32, 0u32, 0u32)
  block = Block(location);
  statement =  Statement(block, StateType.Print, location)
  expr = Expr.newConstant(Value("Hello, World!\n"), location)
  statement.insertExpr(expr)
  statement.dump()
}
